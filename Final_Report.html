<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Haolin Zhong, Shaocong Zhang, Yuxuan Wang, Boqian Li" />


<title>Final Report</title>

<script src="site_libs/header-attrs-2.11/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/readable.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<script src="site_libs/kePrint-0.0.1/kePrint.js"></script>
<link href="site_libs/lightable-0.0.1/lightable.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>








<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Home</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="Proposal.html">Proposal</a>
</li>
<li>
  <a href="EDA.html">Exploratory Analyses</a>
</li>
<li>
  <a href="tree-based-bootstraping.html">Differentiable Movies</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Recommendation Algorithm
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="user_similarity.html">Similarity-based Recommendation</a>
    </li>
    <li>
      <a href="SVD.html">Latent-factor-based Recommendation</a>
    </li>
    <li>
      <a href="tag_system_recommendation.html">Tag-based Recommendation</a>
    </li>
  </ul>
</li>
<li>
  <a href="https://hzhong.shinyapps.io/movierecommender/">Shinyapp</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="Final_Report.html">Project Report</a>
</li>
<li>
  <a href="https://github.com/ShaocongZ/Final_Project/">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Final Report</h1>
<h4 class="author">Haolin Zhong, Shaocong Zhang, Yuxuan Wang, Boqian Li</h4>
<h4 class="date">12/7/2021</h4>

</div>


<p> </p>
<div id="motivation" class="section level1">
<h1>Motivation</h1>
<p>The prosperity of Internet industry enabled massive knowledge and entertainments to be accessible at one’s fingertips, making people no longer in thirst for feeds. However, massive information also trapped people into another dilemma: we got numerous choices for our limited attentions. Therefore, many Internet companies, such as Youtube, Tiktok and Bilibili, has equipped their website with personalized recommendation service in their backend to attract users’ attentions as much as possible. Curious about what’s behind the curtain, we decide to learn and implement recommendation algorithms to build our own recommendation system.</p>
<p> </p>
</div>
<div id="related-work" class="section level1">
<h1>Related work</h1>
<p>For film industry, good recommendation algorithm may worth billions of dollars. A living example is <a href="https://en.wikipedia.org/wiki/Netflix_Prize">Netflix Prize</a>, where <a href="https://sifter.org/~simon/journal/20061211.html">Funk-SVD</a> was proposed.</p>
<p>As we are short in computing power needed to train the Funk-SVD model, we then turned to consult the book, Implementation of Recommend System by Liang Xiang, to learn other applicable algorithms.</p>
<p> </p>
</div>
<div id="initial-questions" class="section level1">
<h1>Initial questions</h1>
<ul>
<li>What movies are both popular and highly-rated?</li>
<li>Is there any significant differences in ratings of movies in different genres? (Which types of movie do people like?)</li>
<li>Is there any relationship between movie ratings and movie release year? (Have movie ratings worsened in recent years?)</li>
<li>For new users entering into the recommendation system, how to gain the first batch of rating information?</li>
<li>For existing users, how to recommend movies to them?</li>
</ul>
<p> </p>
</div>
<div id="data" class="section level1">
<h1>Data</h1>
<div id="source" class="section level3">
<h3>Source</h3>
<p>The Dataset source used for EDA analysis is:<a href="https://grouplens.org/datasets/movielens/latest/">MoiveLensdataset</a></p>
<ul>
<li><p>MovieLens, a movie recommendation service, provided this dataset (ml-latest-small), which describes rating measured in the 5-star format and free-text tagging activities. It has 100836 ratings and 3683 tags generated by 610 users over 9742 movies between March 29, 1996 and September 24, 2018. This dataset was last updated on September 26, 2018.</p></li>
<li><p>Users in the dataset were chosen at random. All users chosen had rated at least 20 films. An id is assigned to each user, and no additional information is supplied.</p></li>
<li><p>The dataset was distributed in three files, movies.csv, ratings.csv, and tags.csv.</p>
<ul>
<li>“movies.csv” includes <code>movieId</code>(movie ID), <code>title</code>(movie title) and <code>genres</code>(movie genres).</li>
<li>“ratings.csv” contains <code>userId</code> (user ID), <code>movieId</code> (movie ID), <code>rating</code> and <code>timestamp</code> (which represents the timepoint at which the rating was given).</li>
<li>“tag.csv” includes <code>userId</code>, <code>movieId</code>, <code>tag</code> (text generated by a user to a movie) and <code>timestamp</code>.</li>
</ul></li>
</ul>
<p> </p>
</div>
<div id="data-cleaning" class="section level3">
<h3>Data cleaning</h3>
<div id="data-cleaning-for-eda" class="section level4">
<h4>Data cleaning for EDA</h4>
<pre class="r"><code>library(tidyverse)
data_path = &quot;./data/small/ratings.csv&quot;

rating_tidy = 
  read_csv(data_path, col_types = &quot;ccnc&quot;) %&gt;% 
    janitor::clean_names() %&gt;% 
    select(-timestamp) %&gt;% 
    mutate(rating = as.double(rating))  

high_rating = 
  rating_tidy %&gt;% 
  filter(rating == 5.0) 

movie_names = 
  read_csv(&quot;./data/small/movies.csv&quot;) %&gt;% 
  rename(movie_id = movieId)</code></pre>
<p>Data cleaning was performed for EDA. For dataset “rating.csv”, we applied the <code>janitor::clean_names()</code> function to make sure that everything is in lower case, and we also excluded the <code>timestamp</code> variable that did not related to our analysis assumption. After this step, we set up a new data frame called “rating_tidy”. Next up, we also created a new dataframe called “high_rating”, which only contains the highest rating score “5” of the “rating_tidy” dataframe. Last but not least, we renamed the variable “movieId” to movie_id for the “movie.csv” dataset and transfered it to a new data frame called “movie_names”. Other trivial data cleaning process were mentioned in the following EDA section.</p>
<p> </p>
</div>
<div id="data-cleaning-for-finding-most-differentiable-movies" class="section level4">
<h4>Data cleaning for finding most differentiable movies</h4>
<p>In finding most differentiable movies, we have done following data cleaning:</p>
<ul>
<li>extract <code>year</code> of release from the title of the movie</li>
<li>filter on <code>year</code> to only include movies released after 2000</li>
<li>find number of ratings of each movie, and select 100 movies with most ratings</li>
<li>convert numerical ratings into categorical variable which has three levels, <code>lover</code>, <code>hater</code>, <code>unknown</code></li>
</ul>
<p> </p>
<div id="filter-movies-released-after-2000" class="section level5">
<h5>Filter movies released after 2000</h5>
<pre class="r"><code>cut_year = function(string){
  # str_split() returns a list with 1 element, 
  # which is a vector containing splitted strings
  year_str = str_split(string, pattern = &quot;\\(&quot;)[[1]]
  
  # sometimes the movie name also contains brackets,
  # so we only take the last element in the vector,
  # which must be the release year.
  year_str = str_remove(year_str[length(year_str)], &quot;\\)&quot;)
  return(year_str)
}

movies = read_csv(&quot;./data/small/movies.csv&quot;) %&gt;% 
  janitor::clean_names() %&gt;% 
  mutate(
    year = map(title, cut_year),
    year = as.integer(year)
  ) %&gt;% 
  arrange(desc(year)) %&gt;% 
  drop_na(year) %&gt;% 
  filter(year &gt;= 2000) %&gt;% 
  select(movie_id, year)</code></pre>
<p>We built a function <code>cut_year</code> to extract <code>year</code> from <code>title</code>, and filtered movies released after 2000. The format of <code>title</code> is <code>[movie name] ([release year])</code>, thus we extracted <code>year</code> through identifying brackets in <code>title</code>.</p>
<p> </p>
</div>
<div id="find-100-movies-with-most-ratings" class="section level5">
<h5>Find 100 movies with most ratings</h5>
<pre class="r"><code>rating_tidy = read_csv(&quot;./data/small/ratings.csv&quot;, col_types = &quot;iinc&quot;) %&gt;% 
  janitor::clean_names()


hot_movies = 
  rating_tidy %&gt;% 
  count(movie_id) %&gt;%
  # right join previous tibble to filter movies released after 2000
  right_join(movies, by = &quot;movie_id&quot;) %&gt;% 
  arrange(desc(n)) %&gt;% 
  head(100) %&gt;% 
  arrange(movie_id) %&gt;% 
  pull(movie_id) %&gt;% 
  as_vector()</code></pre>
<p>We built a data frame containing all users’ ratings on all movies, and found 100 movies with most ratings released after 2000. These movies were candidate for differentiable movies.</p>
<p> </p>
</div>
<div id="convert-rating-into-categorical-variable-type" class="section level5">
<h5>Convert rating into categorical variable <code>type</code></h5>
<p>The algorithm we implemented demands a variable suggest user’s attitude toward movies, which should have three levels: <code>lover</code>, <code>hater</code>, <code>unknown</code>. Therefore, We converted numerical ratings into this variable, <code>type</code>.</p>
<p> </p>
<div id="generate-the-cartesian-product-of-users-ratings-on-movies" class="section level6">
<h6>Generate the Cartesian product of users’ ratings on movies</h6>
<pre class="r"><code>rating_dscts = 
  rating_tidy %&gt;% 
  select(-timestamp) %&gt;% 
  filter(movie_id %in% hot_movies) %&gt;% 
  # pivot_wider will generate a matrix of user&#39;s rating towards movies, 
  # through which NA will be introduced when the user haven&#39;t seen the movie
  pivot_wider(names_from = movie_id, values_from = rating) %&gt;% 
  # by using pivot_longer to transform this matrix back to tidy data,
  # we introduced NA in the rating column, which suggest the user haven&#39;t seen the movie
  pivot_longer(cols = as.character(hot_movies), names_to = &quot;movie_id&quot;, values_to = &quot;rating&quot;)</code></pre>
<p>For each user, the raw rating file only includes records for movies they rated. To generate a variable which can suggest that the user haven’t seen this movie, we generated the Cartesian product of users’ ratings on movies at first.</p>
<p> </p>
</div>
<div id="conversion" class="section level6">
<h6>Conversion</h6>
<pre class="r"><code>classify = function(rating) {
  res = &quot;&quot;
  # if rating is NA, then the user has not seen this movie yet.
  if (is.na(rating)) {
    res = &quot;unknown&quot;
    
  # if rating &gt; 3.5, we consider the user is a &quot;lover&quot; of this movie
  } else if (rating &gt;= 3.5) {
    # 
    res = &quot;lover&quot;
    
  # otherwise, we consider the user the movie&#39;s hater 
  } else {
    res = &quot;hater&quot;
  }
  
  return(res)
}

user_cate =
  rating_dscts %&gt;%
  mutate(type = map(rating, classify)) %&gt;% 
  unnest(type) %&gt;% 
  mutate(movie_id = as.numeric(movie_id))</code></pre>
<p>In our exploratory analysis, we found that the median of all ratings is 3.5. Thus, if a user’s rating towards a movie is greater or equal to 3.5, we consider the user to be a “lover” of this movie, otherwise we consider the user the movie’s hater. If the rating is <code>NA</code>, then we know the user has not seen this movie and denote “unknown”.</p>
<p> </p>
</div>
</div>
</div>
<div id="data-cleaning-for-latent-factor-based-recommendation" class="section level4">
<h4>Data cleaning for latent-factor-based recommendation</h4>
<pre class="r"><code>data_path = &quot;./data/small/ratings.csv&quot;

rating_tidy = read_csv(data_path, col_types = &quot;ccnc&quot;) %&gt;% 
    janitor::clean_names() %&gt;% 
    select(-timestamp) %&gt;% 
    mutate(rating = as.double(rating))

rating_matrix = rating_tidy %&gt;% 
    pivot_wider(names_from = movie_id, values_from = rating, values_fill = 0.0) %&gt;% 
    column_to_rownames(&quot;user_id&quot;) %&gt;% 
    as.matrix()

users = rownames(rating_matrix)[1:20]
movies = colnames(rating_matrix)[1:20]

rating_matrix = rating_matrix[users, movies]</code></pre>
<p>For latent-factor-based recommendation, we built a dataframe from the raw rating file. Then, we transformed the tidy data into a rating matrix, with column represent movies, rows represent users, and values in each grid represent ratings.</p>
<p>Due to the limitation of computing power, we only predict ratings for the first 20 users and the first 20 movies in the dataset.</p>
<p> </p>
</div>
<div id="data-cleaning-for-user-generated-tags" class="section level4">
<h4>Data cleaning for user-generated tags</h4>
<p>In tag-based recommendation, we used the “tag.csv” dataset. After using <code>janitor::clean_names()</code> to clean the variable names, we used the <code>strsplit</code> function to split tags into single words. In this way, punctuation marks (like comma, parenthesis) and “less important” words (like “a”, “too”) become the main barriers to the data cleaning process.</p>
<p>In order to removing the punctuation marks in the dataset, we applied <code>removePunctuation()</code> to the dataset and successfully removed all the punctutation.</p>
<p>The “less important” words are more complicated. Fortunately, a <a href="https://countwordsfree.com/stopwords">stop list</a> helped us a lot, which contains the stop words that are frequently used in different languages (we only considered English in this project). Then, we removed words contained in the stop list and prepared the dataset for tag-based recommendation.</p>
<p> </p>
</div>
</div>
</div>
<div id="exploratory-analysis" class="section level1">
<h1>Exploratory analysis</h1>
<p> </p>
<div id="summaries" class="section level2">
<h2>Summaries</h2>
<div id="overview-of-dataset-ratings.csv" class="section level3">
<h3>Overview of dataset “ratings.csv”</h3>
<p>We first imported the dataset “ratings.csv”, and applied <code>janitor::clean_names()</code> to made everything into lower cases. Next, we applied the <code>summary()</code> function to get the summary table. According to the result, for variable <code>rating</code>, the minimum is 0.5, the first quantile is 3, median is 3.5, mean is 3.502, the third quantile is 4 and the maximum is 5. Since userid, movieid, timestamp only represented the ID of users, id of movies and rating generated time, we chose not to analyze those three variables.</p>
<pre class="r"><code>knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(readr)
library(ggplot2)
library(kableExtra)
library(pastecs)
library(ggpubr)
library(tm)
data_path = &quot;./data/small/ratings.csv&quot;
summary_df = 
  read_csv(data_path, col_types = &quot;ccnc&quot;) %&gt;% 
  janitor::clean_names() %&gt;% 
  summary(summary_df$rating) %&gt;% 
  knitr::kable() %&gt;% 
  kable_styling(bootstrap_options = c(&quot;striped&quot;)) %&gt;%
  kableExtra::kable_styling(font_size = 12)
summary_df</code></pre>
<table class="table table-striped table" style="margin-left: auto; margin-right: auto; font-size: 12px; margin-left: auto; margin-right: auto;">
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:left;">
user_id
</th>
<th style="text-align:left;">
movie_id
</th>
<th style="text-align:left;">
rating
</th>
<th style="text-align:left;">
timestamp
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
Length:100836
</td>
<td style="text-align:left;">
Length:100836
</td>
<td style="text-align:left;">
Min. :0.500
</td>
<td style="text-align:left;">
Length:100836
</td>
</tr>
<tr>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
Class :character
</td>
<td style="text-align:left;">
Class :character
</td>
<td style="text-align:left;">
1st Qu.:3.000
</td>
<td style="text-align:left;">
Class :character
</td>
</tr>
<tr>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
Mode :character
</td>
<td style="text-align:left;">
Mode :character
</td>
<td style="text-align:left;">
Median :3.500
</td>
<td style="text-align:left;">
Mode :character
</td>
</tr>
<tr>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
NA
</td>
<td style="text-align:left;">
NA
</td>
<td style="text-align:left;">
Mean :3.502
</td>
<td style="text-align:left;">
NA
</td>
</tr>
<tr>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
NA
</td>
<td style="text-align:left;">
NA
</td>
<td style="text-align:left;">
3rd Qu.:4.000
</td>
<td style="text-align:left;">
NA
</td>
</tr>
<tr>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
NA
</td>
<td style="text-align:left;">
NA
</td>
<td style="text-align:left;">
Max. :5.000
</td>
<td style="text-align:left;">
NA
</td>
</tr>
</tbody>
</table>
<p> </p>
</div>
<div id="overview-of-dataset-movies.csv" class="section level3">
<h3>Overview of dataset “movies.csv”</h3>
<p>We imported the dataset “movies.csv”, and applied <code>janitor::clean_names()</code> to made everything into lower cases. We also applied <code>separate()</code> function to separate the year of the variable “title”. Next, we count the genres by <code>count()</code> function. We also applied the <code>filter()</code> function to keep the n number lager than 1500.</p>
<pre class="r"><code>data_path = &quot;./data/small/movies.csv&quot;

movie_descriptive = 
  read_csv(&quot;./data/small/movies.csv&quot;) %&gt;% 
  janitor::clean_names() %&gt;%
  separate(
  title, c(&quot;name&quot;, &quot;year&quot;), sep=&quot;\\s+(?=\\S*$)&quot;) %&gt;% 
  separate_rows(genres, sep = &quot;[|]&quot;) 
  
genres_count =
  movie_descriptive %&gt;% 
  group_by(genres) %&gt;% 
  count(genres) %&gt;% 
  filter(n &gt;= 1500) %&gt;% 
  arrange(desc(n)) %&gt;% 
  knitr::kable() %&gt;% 
  kable_styling(bootstrap_options = c(&quot;striped&quot;)) %&gt;%
  kableExtra::kable_styling(font_size = 12)

genres_count</code></pre>
<table class="table table-striped table" style="margin-left: auto; margin-right: auto; font-size: 12px; margin-left: auto; margin-right: auto;">
<thead>
<tr>
<th style="text-align:left;">
genres
</th>
<th style="text-align:right;">
n
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Drama
</td>
<td style="text-align:right;">
4361
</td>
</tr>
<tr>
<td style="text-align:left;">
Comedy
</td>
<td style="text-align:right;">
3756
</td>
</tr>
<tr>
<td style="text-align:left;">
Thriller
</td>
<td style="text-align:right;">
1894
</td>
</tr>
<tr>
<td style="text-align:left;">
Action
</td>
<td style="text-align:right;">
1828
</td>
</tr>
<tr>
<td style="text-align:left;">
Romance
</td>
<td style="text-align:right;">
1596
</td>
</tr>
</tbody>
</table>
<p>Next, we also counted the 5 most appeared release year of movies, i.e. the 5 most prolific year for movie industry.</p>
<pre class="r"><code>year_count =
  movie_descriptive %&gt;% 
  group_by(year) %&gt;% 
  count(year) %&gt;% 
  filter(n &gt;= 690) %&gt;% 
  arrange(desc(n)) %&gt;%  
  knitr::kable() %&gt;% 
  kable_styling(bootstrap_options = c(&quot;striped&quot;)) %&gt;%
  kableExtra::kable_styling(font_size = 12)
year_count</code></pre>
<table class="table table-striped table" style="margin-left: auto; margin-right: auto; font-size: 12px; margin-left: auto; margin-right: auto;">
<thead>
<tr>
<th style="text-align:left;">
year
</th>
<th style="text-align:right;">
n
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
<ol start="2006" style="list-style-type: decimal">
<li></td>
<td style="text-align:right;">
733
</td>
</tr>
<tr>
<td style="text-align:left;">
<ol start="2009" style="list-style-type: decimal">
<li></td>
<td style="text-align:right;">
719
</td>
</tr>
<tr>
<td style="text-align:left;">
<ol start="2005" style="list-style-type: decimal">
<li></td>
<td style="text-align:right;">
709
</td>
</tr>
<tr>
<td style="text-align:left;">
<ol start="2002" style="list-style-type: decimal">
<li></td>
<td style="text-align:right;">
705
</td>
</tr>
<tr>
<td style="text-align:left;">
<ol start="2008" style="list-style-type: decimal">
<li></td>
<td style="text-align:right;">
691
</td>
</tr>
</tbody>
</table></li>
</ol></li>
</ol></li>
</ol></li>
</ol></li>
</ol>
<p> </p>
</div>
</div>
<div id="exploratory-statistical-analyses" class="section level2">
<h2>Exploratory Statistical Analyses</h2>
<div id="find-movies-receive-most-5-star-ratings" class="section level3">
<h3>Find movies receive most 5-star ratings</h3>
<p>We first merged the “high_rating” and “movie_names” dataframes, and counted the <code>movie_id</code> variable and filtered movies with over 100 ratings. Next, we re-arranged rows according to the count and separated release year of movies from <code>title</code> as <code>year</code>. One interesting factis that among the 5 movies, 3 movies were released in 1994; 4 movies were released in the 90s.</p>
<pre class="r"><code>data_path = &quot;./data/small/ratings.csv&quot;

rating_tidy = 
  read_csv(data_path, col_types = &quot;ccnc&quot;) %&gt;% 
    janitor::clean_names() %&gt;% 
    select(-timestamp) %&gt;% 
    mutate(rating = as.double(rating))  

high_rating = 
  rating_tidy %&gt;% 
  filter(rating == 5.0) 

movie_names = 
  read_csv(&quot;./data/small/movies.csv&quot;) %&gt;% 
  rename(movie_id = movieId)

high_rating_movienames = 
  merge(high_rating, movie_names) %&gt;% 
  group_by(title, genres,rating) %&gt;% 
  count(movie_id) %&gt;% 
  filter(n &gt;= 100) %&gt;% 
  select(n,title,genres,rating) %&gt;% 
  ungroup(title, genres,rating) %&gt;% 
  arrange(desc(n)) %&gt;% 
  separate(
  title, c(&quot;name&quot;, &quot;year&quot;), sep=&quot;\\s+(?=\\S*$)&quot;) %&gt;% 
  knitr::kable() %&gt;% 
  kable_styling(bootstrap_options = c(&quot;striped&quot;)) %&gt;%
  kableExtra::kable_styling(font_size = 12)
  
high_rating_movienames </code></pre>
<table class="table table-striped table" style="margin-left: auto; margin-right: auto; font-size: 12px; margin-left: auto; margin-right: auto;">
<thead>
<tr>
<th style="text-align:right;">
n
</th>
<th style="text-align:left;">
name
</th>
<th style="text-align:left;">
year
</th>
<th style="text-align:left;">
genres
</th>
<th style="text-align:right;">
rating
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right;">
153
</td>
<td style="text-align:left;">
Shawshank Redemption, The
</td>
<td style="text-align:left;">
<ol start="1994" style="list-style-type: decimal">
<li></td>
<td style="text-align:left;">
Crime|Drama
</td>
<td style="text-align:right;">
5
</td>
</tr>
<tr>
<td style="text-align:right;">
123
</td>
<td style="text-align:left;">
Pulp Fiction
</td>
<td style="text-align:left;">
<ol start="1994" style="list-style-type: decimal">
<li></td>
<td style="text-align:left;">
Comedy|Crime|Drama|Thriller
</td>
<td style="text-align:right;">
5
</td>
</tr>
<tr>
<td style="text-align:right;">
116
</td>
<td style="text-align:left;">
Forrest Gump
</td>
<td style="text-align:left;">
<ol start="1994" style="list-style-type: decimal">
<li></td>
<td style="text-align:left;">
Comedy|Drama|Romance|War
</td>
<td style="text-align:right;">
5
</td>
</tr>
<tr>
<td style="text-align:right;">
109
</td>
<td style="text-align:left;">
Matrix, The
</td>
<td style="text-align:left;">
<ol start="1999" style="list-style-type: decimal">
<li></td>
<td style="text-align:left;">
Action|Sci-Fi|Thriller
</td>
<td style="text-align:right;">
5
</td>
</tr>
<tr>
<td style="text-align:right;">
104
</td>
<td style="text-align:left;">
Star Wars: Episode IV - A New Hope
</td>
<td style="text-align:left;">
<ol start="1977" style="list-style-type: decimal">
<li></td>
<td style="text-align:left;">
Action|Adventure|Sci-Fi
</td>
<td style="text-align:right;">
5
</td>
</tr>
</tbody>
</table></li>
</ol></li>
</ol></li>
</ol></li>
</ol></li>
</ol>
<p> </p>
</div>
<div id="find-the-average-rating-of-each-genres-in-different-year" class="section level3">
<h3>Find the average rating of each genres in different year</h3>
<p>As to find out the average rating of each genres in different year, we used <code>separate()</code> to separate the combined genre. Then, we found the average rating in different genres by using <code>group_by()</code> and <code>summarize()</code>. Here we only display the first ten rows of this dataframe:</p>
<pre class="r"><code>movie_names_ave = 
  read_csv(&quot;./data/small/movies.csv&quot;) %&gt;% 
  rename(movie_id = movieId) %&gt;% 
  separate(
  title, c(&quot;name&quot;, &quot;year&quot;), sep=&quot;\\s+(?=\\S*$)&quot;) %&gt;% 
  separate_rows(genres, sep = &quot;[|]&quot;) %&gt;%
  filter(!genres  %in% &quot;(no genres listed)&quot;) 

filter_ratingscore = 
  rating_tidy  

ave_rating = 
  merge(filter_ratingscore, movie_names_ave) %&gt;% 
  group_by(year,genres) %&gt;%
  summarize(mu_rating = mean(rating)) %&gt;% 
  head(10) %&gt;% 
  knitr::kable() %&gt;%
  kable_styling(bootstrap_options = c(&quot;striped&quot;)) %&gt;%
  kableExtra::kable_styling(font_size = 12)
ave_rating</code></pre>
<table class="table table-striped table" style="margin-left: auto; margin-right: auto; font-size: 12px; margin-left: auto; margin-right: auto;">
<thead>
<tr>
<th style="text-align:left;">
year
</th>
<th style="text-align:left;">
genres
</th>
<th style="text-align:right;">
mu_rating
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
<ol start="1902" style="list-style-type: decimal">
<li></td>
<td style="text-align:left;">
Action
</td>
<td style="text-align:right;">
3.5
</td>
</tr>
<tr>
<td style="text-align:left;">
<ol start="1902" style="list-style-type: decimal">
<li></td>
<td style="text-align:left;">
Adventure
</td>
<td style="text-align:right;">
3.5
</td>
</tr>
<tr>
<td style="text-align:left;">
<ol start="1902" style="list-style-type: decimal">
<li></td>
<td style="text-align:left;">
Fantasy
</td>
<td style="text-align:right;">
3.5
</td>
</tr>
<tr>
<td style="text-align:left;">
<ol start="1902" style="list-style-type: decimal">
<li></td>
<td style="text-align:left;">
Sci-Fi
</td>
<td style="text-align:right;">
3.5
</td>
</tr>
<tr>
<td style="text-align:left;">
<ol start="1903" style="list-style-type: decimal">
<li></td>
<td style="text-align:left;">
Crime
</td>
<td style="text-align:right;">
2.5
</td>
</tr>
<tr>
<td style="text-align:left;">
<ol start="1903" style="list-style-type: decimal">
<li></td>
<td style="text-align:left;">
Western
</td>
<td style="text-align:right;">
2.5
</td>
</tr>
<tr>
<td style="text-align:left;">
<ol start="1908" style="list-style-type: decimal">
<li></td>
<td style="text-align:left;">
Animation
</td>
<td style="text-align:right;">
4.0
</td>
</tr>
<tr>
<td style="text-align:left;">
<ol start="1908" style="list-style-type: decimal">
<li></td>
<td style="text-align:left;">
Comedy
</td>
<td style="text-align:right;">
4.0
</td>
</tr>
<tr>
<td style="text-align:left;">
<ol start="1908" style="list-style-type: decimal">
<li></td>
<td style="text-align:left;">
Sci-Fi
</td>
<td style="text-align:right;">
4.0
</td>
</tr>
<tr>
<td style="text-align:left;">
<ol start="1915" style="list-style-type: decimal">
<li></td>
<td style="text-align:left;">
Drama
</td>
<td style="text-align:right;">
2.0
</td>
</tr>
</tbody>
</table></li>
</ol></li>
</ol></li>
</ol></li>
</ol></li>
</ol></li>
</ol></li>
</ol></li>
</ol></li>
</ol></li>
</ol>
<p> </p>
</div>
<div id="kruskal-wallis-test-regarding-user-id-and-rating" class="section level3">
<h3>Kruskal-Wallis Test regarding user ID and rating</h3>
<p>We performed Kruskal-Wallis Test to determine whether there were any statistically significant differences among each users’ mean rating. The Kruskal-Wallis H test (also known as the “one-way ANOVA on ranks”) is a rank-based nonparametric test that may be used to see if two or more groups of an independent variable on a continuous or ordinal dependent variable have statistically significant differences. This method is the nonparametric counterpart of the one-way ANOVA (Kruskal-Wallis H Test in SPSS Statistics | Procedure, output and interpretation of the output using a relevant example., 2021). We choose this method instead of ANOVA due to non-normality of ratings.</p>
<p>Our assumption for KW test were:</p>
<p><span class="math display">\[
\begin{align}
&amp; H_0:\mu_{0}=\mu_1=\mu_2=\mu_3=...=\mu _x \\
&amp; H_1: \text{At least two of the mean ratings of the users are different}
\end{align}
\]</span></p>
<p>The result showed that the p value was less than 0.05. We can thus concluded that at 0.05 significance level, we rejected the null hypothesis and concluded that at least two of the mean ratings of the user from the 600 users were different.</p>
<pre class="r"><code>ggplot(filter_ratingscore, aes(x = rating, y = ..density..)) + 
  geom_histogram(alpha = 0.3, bins = 30) </code></pre>
<p><img src="Final_Report_files/figure-html/unnamed-chunk-12-1.png" width="672" /></p>
<pre class="r"><code>kruskal.test(rating ~ user_id, data = filter_ratingscore) %&gt;% 
 broom::tidy() %&gt;% 
 kableExtra::kbl() %&gt;% 
 kable_styling(bootstrap_options = c(&quot;striped&quot;)) %&gt;%
  kableExtra::kable_styling(font_size = 12)</code></pre>
<table class="table table-striped table" style="margin-left: auto; margin-right: auto; font-size: 12px; margin-left: auto; margin-right: auto;">
<thead>
<tr>
<th style="text-align:right;">
statistic
</th>
<th style="text-align:right;">
p.value
</th>
<th style="text-align:right;">
parameter
</th>
<th style="text-align:left;">
method
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right;">
20676.72
</td>
<td style="text-align:right;">
0
</td>
<td style="text-align:right;">
609
</td>
<td style="text-align:left;">
Kruskal-Wallis rank sum test
</td>
</tr>
</tbody>
</table>
<p><strong>Note</strong>: The actual p-value is less than 2.2e-16, which is too small to be shown in r. Thus, the p-value showed in the table is 0.</p>
<p> </p>
</div>
</div>
<div id="visualizations" class="section level2">
<h2>Visualizations</h2>
<div id="rating-distributions-among-different-genres" class="section level3">
<h3>Rating distributions among different genres</h3>
<p>After completing data cleaning process mentioned in previous sections, we merged the two dataframes, <code>filter_ratingscore</code> and <code>movie_names</code>, cleaned all column names into lower cases, extracted <code>genres</code>. Finally, we created a violin plot regarding ratings and genres. The plot showed that there is no obvious difference in ratings distributions among different genres.</p>
<pre class="r"><code>movie_names = 
  read_csv(&quot;./data/small/movies.csv&quot;) %&gt;% 
  rename(movie_id = movieId) %&gt;% 
  separate(
  title, c(&quot;name&quot;, &quot;year&quot;), sep=&quot;\\s+(?=\\S*$)&quot;) 

filter_ratingscore = 
  rating_tidy

violin_df = 
  merge(filter_ratingscore, movie_names) %&gt;%
  janitor::clean_names() %&gt;%
  separate_rows(genres, sep = &quot;[|]&quot;) %&gt;%
  filter(!genres  %in% &quot;(no genres listed)&quot;) %&gt;% 
  ggplot(aes(x = rating, y = genres)) + geom_violin(aes(color = genres, alpha = .5)) +
  theme(legend.position=&quot;none&quot;) 
  viridis::scale_color_viridis(discrete = TRUE)

violin_df</code></pre>
<p><img src="Final_Report_files/figure-html/unnamed-chunk-14-1.png" width="672" /></p>
<p> </p>
</div>
<div id="rating-distribution-among-different-years" class="section level3">
<h3>Rating distribution among different years</h3>
<p>After completing data cleaning process mentioned in previous sections, we removed brackets in <code>year</code>, and only included movies released between 1990 and 2018. We made a violin plot to show the rating distributions among movie release years. We found an obvious trend that from 1990 to 2018, the average rating score of movies has become more and more “similar”. That is, the rating values of modern movies are more frequently concentrated between 3.5 and 4, and the density of corresponding scores is close. However, compared to the modern movies from 2000, the user preference for movies from the 90s is more divided, and the density between different ratings is more obvious.</p>
<pre class="r"><code>movie_names = 
  read_csv(&quot;./data/small/movies.csv&quot;) %&gt;% 
  rename(movie_id = movieId) %&gt;% 
  separate(
  title, c(&quot;name&quot;, &quot;year&quot;), sep=&quot;\\s+(?=\\S*$)&quot;) 

selected_years = 1990:2018

violin_df2 = 
  merge(filter_ratingscore, movie_names) %&gt;%
  mutate(
    year = removePunctuation(year)
  ) %&gt;% 
  filter(year %in% selected_years) %&gt;% 
  ggplot(aes(x = rating, y = year)) + 
  geom_violin(aes(color = year))+
  theme(legend.position=&quot;none&quot;) 
  viridis::scale_fill_viridis(discrete = TRUE)

violin_df2 </code></pre>
<p><img src="Final_Report_files/figure-html/unnamed-chunk-15-1.png" width="672" /></p>
<p> </p>
</div>
</div>
</div>
<div id="additional-analyses" class="section level1">
<h1>Additional analyses</h1>
<div id="identification-of-differentiable-movies" class="section level3">
<h3>Identification of differentiable movies</h3>
<p>We implemented adaptive bootstrapping algorithm <a href="https://dl.acm.org/doi/10.1145/1935826.1935910">(Golbandi, N., et al. 2011)</a> to find movies significantly differentiate people of different taste.</p>
<p> </p>
<p>According to user’s response to the given movie, the algorithm classifies users into three sub-groups: lovers <span class="math inline">\(N^{+}\)</span>, haters <span class="math inline">\(N^{-}\)</span>, and people unknown of the movie <span class="math inline">\(\overline{N}\)</span>. We choose 3.5 as the cut-off to determine whether users are lovers or haters, as our exploratory analysis found that 3.5 is the median of all ratings.</p>
<p> </p>
<p>The algorithm defined a term <span class="math inline">\(D_{m}\)</span>, which is equal to the sum of subgroups’ standard deviation of ratings on other movies (<span class="math inline">\(\space D(m) = \sigma_{u \in N^{+}(m)} + \sigma_{u \in N^{-}(m)} + \sigma_{u \in \overline{N}(m)} \space\)</span>), to measure movies’ differentiation ability. By the definition, the most differential movie, i.e. the best splitter, should have the lowest <span class="math inline">\(D_{m}\)</span>, because bad splitters will divide people with different taste into the same sub-group, resulting in increased <span class="math inline">\(D_{m}\)</span>.</p>
<p> </p>
<p>Once the algorithm found the most differential movie for overall users, it will repeat the above process in the 3 sub-groups, Lovers, haters and people unknown of this movie, separately. This recursive process was thus named bootstrapping. Subsequently, the algorithm will build a structure similar to a decision tree whose nodes are movies. Our implementation constructed such a ternary tree structure with a depth of 3. The result can be interpreted by the figure below:</p>
<p><img src="pics/recsys.png" style="width:80%"></p>
<p> </p>
<p>For new users, let them rate on “The Last Samurai” at first. Users who give ratings above or equal to 3.5 are considered to be lovers, and those who give ratings below 3.5 are considered to be haters. Users can also reply that they haven’t watched this movie. For lovers, we then let them rate on “The Lord of the Rings: The Two Towers”, for haters we let them rate on “Finding Nemo”, and the unknown will be asked to rate on “City of God”. After rating on the second provided movie, users will then be asked to rate on the third movie which is also adaptively provided.</p>
<p> </p>
<p>Since these movies significantly differentiate people of different taste, collection of user’s rating on them will allow us to generate more personalized recommendation.</p>
<p> </p>
</div>
<div id="user-similarity-based-recommendation" class="section level3">
<h3>User-similarity-based recommendation</h3>
<p>A basic strategy for recommendation is, find users similar to the new user, and recommend the new user with what similar users like. Based on this strategy, a technique, collaborative filtering, was invented to making predictions (filtering) about the interests of a user by collecting preferences or taste information from many similar users (collaborating).</p>
<p> </p>
<p>This algorithm predict ratings with the following procedures: - Find K most similar users to the given user (Here we set K to 10) - Find all movies that these similar users have rated and the given user has not watched - Predict the given user’s ratings on these movies based on the similarity measure and ratings of similar users. The formula is:</p>
<p><span class="math display">\[
\hat{r}_{u m}=\bar{r}_{u}+\frac{\sum_{v \in S(u, K) \cap N(m)} w_{u v}\left(r_{v m}-\bar{r}_{v}\right)}{\sum_{v \in S(u, K) \cap N(m)}\left|w_{u v}\right|}
\]</span></p>
<p>In the above process, finding similar users and predicting ratings involve the measurement of similarity, <span class="math inline">\(w_{uv}\)</span>. We considered two measurements, cosine similarity and Pearson correlation, and compared their performance through experimentation.</p>
<p><span class="math display">\[
\begin{align}
&amp; \text{Cosine Similarity}: &amp; w_{u v} = \frac{\sum_{m \in M} r_{u m} \cdot r_{v m}}{\sqrt{\sum_{m \in M}r_{u m}^{2} \cdot \sum_{m \in M}r_{v m}^{2}}}
\\
\\
&amp; \text{Pearson Correlation}: &amp; w_{u v} =\frac{ \sum_{m \in M}\left(r_{u m}-\bar{r}_{u}\right) \cdot\left(r_{v m}-\bar{r}_{v}\right)}{\sqrt{\sum_{m \in M}\left(r_{u m}-\bar{r}_{u}\right)^{2} \sum_{m \in M}\left(r_{v m}-\bar{r}_{v}\right)^{2}}}
\end{align}
\]</span></p>
<p>We performed 30 rounds of experiment. In each round, for each user, we randomly extract 20% records of their ratings as the test dataset, and the remained dataset as train dataset. Then, we use the two similarity measures separately to find similar users and subsequent predicted ratings on corresponding movies in the test dataset. Finally, we compute the RMSE between predicted ratings and actual ratings in the test data set, and get the two RMSE values.</p>
<p> </p>
<p>The <a href="https://shaocongz.github.io/Final_Project/user_similarity.html#Compare_RMSE">comparison between RMSE values</a> of predictions based on the two measurement revealed that in this dataset, Pearson correlation is a better measurement which leads to smaller prediction error. Therefore, we implemented the algorithm with Pearson correlation in our shiny app.</p>
<p> </p>
</div>
<div id="latent-factor-based-recommendation" class="section level3">
<h3>Latent-factor-based recommendation</h3>
<p>we built a latent factor model based on Funk-SVD to predict ratings for existing users in the dataset.</p>
<p> </p>
<p>Funk-SVD was named and authored by <a href="https://sifter.org/~simon/journal/20061211.html">Simon Funk</a>. The core idea of this algorithm is that decompose the user-movie sparse matrix <span class="math inline">\(R\)</span> into two matrix, the user feature matrix <span class="math inline">\(P\)</span> and the movie feature matrix <span class="math inline">\(Q\)</span> which satisfies <span class="math inline">\(R = P \times Q^T\)</span>, then predicted rating by calculating <span class="math inline">\(\displaystyle R_{um} = P_u \cdot Q^T_m\)</span>. Features are latent factors that we can’t and don’t have to directly measure or understand.</p>
<p> </p>
<p>In human words, the interaction between a user’s latent characteristics and a movie’s latent characteristics decides the user’s rating to the movie. Find values of these latent characteristics by decomposing the rating matrix, then predict ratings based on them.</p>
<p> </p>
<p>We implemented this algorithm and predicted ratings on the matrix constructed from the first 20 users and the first 20 movies in the dataset. To find <span class="math inline">\(P\)</span>, <span class="math inline">\(Q\)</span>, we generated two random matrix, and performed gradient descent to minimize the loss to let their product approximate the true rating matrix.</p>
<p> </p>
<p>In gradient descent, the loss function was defined as:</p>
<p><span class="math display">\[\displaystyle L(P, Q) = \sum_{(u, m) \in \text{Train}} \left(R_{um} - P_u \cdot Q^T_m \right)^2  + \lambda \sum_u||P_u||^2 + \lambda \sum_m ||Q_m||^2\]</span></p>
<p>By performing differentiation, we found the partial derivatives of loss to <span class="math inline">\(P\)</span> and to <span class="math inline">\(Q\)</span>:</p>
<p><span class="math display">\[\frac {\partial}{\partial P_u}L = \sum_{m} 2(P_uQ_m^T - R_{um})Q_m + 2\lambda P_u \\ \frac {\partial}{\partial Q_m}L = \sum_{u} 2(P_uQ_m^T - R_{um})P_u + 2\lambda Q_m\]</span></p>
<p>Accordingly, we can update the value of <span class="math inline">\(P\)</span> and <span class="math inline">\(Q\)</span> in each round of gradient descent:</p>
<p><span class="math display">\[P_u := P_u - \alpha \frac {\partial L}{\partial P_u} \\ Q_m := Q_m - \alpha \frac {\partial L}{\partial Q_m}\]</span></p>
<p>Our train process on the train data <a href="https://shaocongz.github.io/Final_Project/SVD.html#Train">minimized the loss to approximately 0</a>. We further applied this model to <a href="https://shaocongz.github.io/Final_Project/SVD.html#Predict__Visualization">predict ratings for NA value in the original rating matrix</a>. With the size of the matrix in the train data enlarges, the time cost for training this model accurately increases. Therefore, we didn’t apply this model in our shiny app or try to optimize this model.</p>
<p> </p>
</div>
<div id="tag-based-recommendation" class="section level3">
<h3>Tag-based recommendation</h3>
<p>In this project, we have implemented several algorithms for recommendation systems, such as tree-based bootstrapping, user-similarity based recommendation, and tree-based bootstrapping. The next one I want to introduce is the tag-based recommendation system algorithm. Before introducing the new recommendation system, we need a new dataset to carry on the thoughts. The “tag.csv” in the Movielens contains the data we are looking for. The dataset includes user id, movie id, tag and time stamp (it represents seconds since midnight Coordinated Universal Time of January 1, 1970, but we will not use this variable in this part). Based on the information, we can construct a personalized recommendation algorithm by:</p>
<ol style="list-style-type: decimal">
<li><p>For every user, find the most commonly used tags</p></li>
<li><p>For each tag, find the movie that labeled by this tag for the most times.</p></li>
<li><p>For the given user, find his most commonly used tags, then recommend to the user the most popular movie labeled by this tag.</p></li>
</ol>
<p>To improve the above strategy and utilizing all tags rather than most used/received tags, we can quantitatively measure a user’s interest to a movie based on all tags given by the user and all tags received by the movie. The formula of the user u’s interest to the movie i is as follows:</p>
<p><span class="math inline">\(p(u, i)=\sum_{b} \frac{n_{u, b}}{\log \left(1+n_{b}^{(u)}\right)} \frac{n_{b, i}}{\log \left(1+n_{i}^{(u)}\right)}\)</span></p>
<p>where <span class="math inline">\(n_{u, b}\)</span> is the number of times that user u has labeled tag b, <span class="math inline">\(n_{b, i}\)</span> is the number of times that movie i has been labeled tag b, <span class="math inline">\(n_b^{(u)}\)</span> records how many different users have used tag b, <span class="math inline">\(n_i^{(u)}\)</span>records how many different users have tagged the movie i. To get the specific value, we should build our function first.</p>
<p> </p>
<p>The difficulty of the function is to find the correct sets of tags or users. To achieve this goal, we manipulated this dataset, counted the corresponding numbers we need during each round. Then, we sum all values we got in each round and get the interest value of the user on specific movie. The function code can be seen <a href="https://shaocongz.github.io/Final_Project/tag_system_recommendation.html#Construct_interest_function">here</a>.</p>
<p> </p>
<p>After building the function, we want to select the most popular movies to see how this function works. That is, we want to visualize the interest value. However, the dataset only contains about 3700 tags. The limited tag amount will destroy the credibility of the tag-based recommendation system, as some users may have given only a few tags and some movies may have only received a few tags. Therefore, we only included several movies that received most tags and several active users. The cut-off is, we select users who have labeled more than 20 movies and movies that has been labeled by at least 4 users. The selected movies’ table is <a href="https://shaocongz.github.io/Final_Project/tag_system_recommendation.html#Find_the_most_popular_movies_and_the_most_active_users">here</a>.</p>
<p> </p>
<p>We created a heat map to visualize the users’ interest values, which is shown below. The horizontal coordinate of the heat map is the movie ID and the vertical coordinate is the user ID, color in each grid represents the value of the user’s interest to the movie. The detailed code is <a href="https://shaocongz.github.io/Final_Project/tag_system_recommendation.html#Create_heat_map">here</a>.</p>
<p><img src="heat_map.png" style="width:75%"></p>
<p> </p>
<p>Tag-based recommendation can help us predict the user’s interest on a certain movie. The algorithm’s validity relies on amount of tags. Therefore, when trained on datasets with ample data of tags, the algorithm will become more accurate.</p>
<p> </p>
<p>The algorithm penalizes popular tags and popular movies to generate more personalized recommendation results.</p>
<p> </p>
</div>
</div>
<div id="discussion" class="section level1">
<h1>Discussion</h1>
<div id="explorotory-data-analysis" class="section level2">
<h2>Explorotory Data Analysis</h2>
<div id="key-finding-insights" class="section level3">
<h3>Key finding &amp; insights</h3>
<p>Our exploratory analyses generated an overview of dataset, and helped us to answer most of our initial questions.</p>
<p>We found movies which received most 5-star ratings, and discovered the top 5 popular and highly-rated movies. The Shawshank Redemption (1994) was the most popular film, with 153 times of 5-star ratings. No. 2 Pulp Fiction (1994) had received 123 5-star ratings. Forrest Gump (1994) came in third position with 116 5-star ratings. The Matrix (1999) was ranked fourth among the top five most popular films, with 109 times of 5-star rating. Star Wars: Episode IV - A New Hope (1977) was ranked No. 5 with 104 5-star. We also discovered an intriguing fact: three of the 5 movies were released in 1994, while four were released in the 1990s.</p>
<p>Besides, we also got rating distributions among genres and movie release years, and noted a trend that From 1990 to 2018, the average rating score of movies has become more and more “similar”. That is, the rating values of modern movies are more frequently concentrated between 3.5 and 4, and the density of corresponding scores is close. However, compared to the modern movies from 2000, the user preference for movies from the 90s is more divided, and the density between different ratings is more obvious.</p>
<p>We also performed Kruskal-Wallis Test, whose result suggests significant differences in users’ ratings.</p>
<p> </p>
</div>
</div>
<div id="additional-analyses-1" class="section level2">
<h2>Additional Analyses</h2>
<div id="finding-differentiable-movies" class="section level3">
<h3>Finding Differentiable Movies</h3>
<p>Through adaptive bootstrapping, we found the most “differentiable” movies in the dataset. We noticed that these movies are basically high-rating movies. This may be resulted from the trend that movies received more ratings tends to be high-rating movies. However, for high-rating movies, most people love them and only a small proportion of people dislike them. The unbalanced population sizes of lovers and haters may affect the calculation of variance of ratings, as a larger population generally has lower variance compared to smaller population, which can subsequently affect the power of <span class="math inline">\(D(m)\)</span> in measuring differentiability. So, such result suggests potential bias caused by our method of filtering popular movies. To avoid such problem, if given a dataset with ample records of ratings, we can further filter popular movies to only include those with balanced population of lovers and haters.</p>
<p> </p>
</div>
<div id="considering-timepoint-of-rating" class="section level3">
<h3>Considering timepoint of rating</h3>
<p>In our analysis, we excluded the variable <code>timestamp</code>, which describes the timepoint that the rating was given at. However, integration of timepoint may significantly improve the performance of models, because a user’s taste may change with time and does not always stay the same. To integrate timepoint, ratings can be adjusted by timepoint, making ratings given earlier become smaller to reward recent ratings as they reflect users’ current taste.</p>
<p> </p>
</div>
<div id="tag-based-recommendation-1" class="section level3">
<h3>Tag-based recommendation</h3>
<p>A tag-based recommendation system can calculate a numerical value by algorithmically visualizing a user’s interest in a movie. Based on the user’s tag set and the tag set of a specific movie, the system calculates the interest value of the movie and recommends the movie to the user based on this value. The molecule of the formula, which is <span class="math inline">\(\sum_{b} n_{u, b} n_{b, i}\)</span>, firstly compute the user’s interest in a certain movie by finding the sets. <span class="math inline">\(B(u)\)</span> is the set of tags that user u has labeled, <span class="math inline">\(B(i)\)</span> is the set of tags that movie i is labeled, <span class="math inline">\(n_{u, b}\)</span> is the number of times that the user u has labeled tag b and <span class="math inline">\(n_{b, i}\)</span> is the number of times that movie i has been labeled tag b</p>
<p>However, this formula tends to give a lot of weight to popular movies corresponding to popular tags, which will lead to recommending popular movies to users, thus reducing the novelty of the recommendation results. To solve these problems, scholars improve this formula by drawing on the idea of TF-IDF and constructing the new formula.</p>
<p><span class="math inline">\(p(u, i)=\sum_{b} \frac{n_{u, b}}{\log \left(1+n_{b}^{(u)}\right)} \frac{n_{b, i}}{\log \left(1+n_{i}^{(u)}\right)}\)</span>,</p>
<p>where <span class="math inline">\(n_b^{(u)}\)</span> records how many different users have used tag b, <span class="math inline">\(n_i^{(u)}\)</span>records how many different users have tagged the movie i. The denominator of the formula is used to appropriately punish popular labels and popular items, but the results will not reduce the offline accuracy of the recommendation results while enhancing the personalization of the recommendation results.</p>
<p>Although we got the interest function of user u on movie i, it was still hard to create the heat map. The main problem was the small dataset. The dataset only contains 58 users and most of them only labeled 1 movie. In this way, if the sample size is not large enough, <span class="math inline">\(n_{b, i}\)</span>, which is the number of times that movie i has been labeled tag b, will always be 0. Then we cannot predict the user’s interest anymore and the heat map then will be bad and doesn’t contain useful information.</p>
<p>Luckily, there are several movies that are popular and some users are active. That is, the movies were labeled by several users and some users labeled numbers of movies. We selected the popular movies and active users and then created a heat map.</p>
<p>It is confirmed that if the sample dataset is large enough, then a person will be able to get the interest of any user for any movie and form a movie recommendation system based on it. For example, the interest value is held, and the movie is recommended to the user if it is larger than a certain standard value; the users with similar movie watching interests can be grouped together, and the movie with the highest interest value in this group of users’ will be recommended. In this project, because of the limited sample dataset, time and experience, we could not go deeper. A further investigation can be done in the future.</p>
<p> </p>
</div>
<div id="shiny-app" class="section level3">
<h3>Shiny app</h3>
<p>We implemented results of adaptive boostrapping and user-similarity based recommendation in our shiny app. Users can rate on adaptively-provided movies found by adaptive boostrapping, or rate on any other movie released after 1990. After rating on at least 3 movies, user can get movies recommended by the user-similarity-based recommendation algorithm. The computation for generating recommendation usually takes 1~3 minutes.</p>
</div>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeCodeFolding("hide" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
