---
title: "Tag-based recommendation"
---

```{r, echo=FALSE, message=FALSE, warning = FALSE}
library(tidyverse)
library(tm)
library(ggridges)
library(dplyr)
library(kableExtra)
```

```{r, echo=FALSE, message=FALSE, warning = FALSE}
# data import
movies = read_csv("./data/small/movies.csv")
ratings = read_csv("./data/small/ratings.csv")
tags = read_csv("./data/small/tags.csv")
```

```{r, echo=FALSE, message=FALSE, warning = FALSE}
# data wrangling
tags.full = 
  tags %>%
  janitor::clean_names() %>%
  mutate(
    tag = strsplit(tag, " ")
  ) %>%
  unnest() %>% 
  mutate(tag = tolower(tag))

remove.list = read_csv("./data/stop_words_english.txt", col_names = FALSE) %>% 
  pull("X1") %>% 
  as_vector()

remove.tag = 
tags.full %>% 
  filter(!tag %in% remove.list) %>%
  mutate(
    tag = removePunctuation(tag)
  ) %>% 
  filter(
    !tag == ""
  )
```

In this project, we have implemented several algorithms for recommendation systems, such as tree-based bootstraping, user-similarity based recommendation, and tree-based bootstrapping. The next one I want to introduce is the tag-based recommendation system algorithm. Before introducing the new recommendation system, we need a new dataset to carry on the thoughts. The "tag.csv" in the Movielens contains the data we are looking for. The dataset includes user id, movie id, tag and time stamp (it represents seconds since midnight Coordinated Universal Time of January 1, 1970, but we will not use this variable in this part). Based on these information, we can construct a personalized recommendation algorithm by:

1. Count the most commonly used tags of the user.

2. For each tag, count the movies that have been labeled the most times.

3. For a user, first find his commonly used tags, and then find the most popular movies with these tags to recommend to the user.

For the above algorithm, the formula of user u's interest in movie i is as follows:

$p(u, i)=\sum_{b} \frac{n_{u, b}}{\log \left(1+n_{b}^{(u)}\right)} \frac{n_{b, i}}{\log \left(1+n_{i}^{(u)}\right)}$

where $B(u)$ is the set of tags that user u has labeled, $B(i)$ is the set of tags that movie i is labeled, $n_{u, b}$ is the number of times that user u has labeled tag b, $n_{b, i}$ is the number of times that movie i has been labeled tag b, $n_b^{(u)}$ records how many different users have used tag b, $n_i^{(u)}$records how many different users have tagged the movie i. To get the specific value, we should build our function first.

### Construct interest function

The difficulty of the function is to find the correct sets of tags or users. To acheive the goal, we use the knowledge we have learned in the class, manipulate the dataset count the corresponding numbers we need during each trail. Sum all of the value we got in each trail and then we can get the interest value of the user on specific movie (or item).

```{r, collapse = TRUE}
# Set up interest function
fc.interest = function(u, i) {
B.u = 
  remove.tag %>% 
  filter(user_id == u)

B.u.distinct = 
  B.u %>% 
  distinct(tag)

remove.tag.distinct = 
  remove.tag %>% 
  select(-movie_id, -timestamp) %>% 
  distinct()

B.i = 
  remove.tag %>% 
  filter(movie_id == i)

B.i.distinct = 
  B.i %>% 
  select(-tag, -timestamp) %>% 
  distinct()

n_ub = c()
n_bi = c()
n_bu = c()
lg.value = c()
n_iu = nrow(B.i.distinct)
value = c()

for (b in 1:nrow(B.u.distinct)) {
  n_ub[b] = sum(B.u$tag == as.character(B.u.distinct[b, 1]))
  n_bi[b] = sum(B.i$tag == as.character(B.u.distinct[b, 1]))
  n_bu[b] = sum(remove.tag.distinct$tag == as.character(B.u.distinct[b, 1]))
  lg.value[b] = log(1 + n_bu[b]) * log(1 + n_iu)
  value[b] = n_ub[b] * n_bi[b] / lg.value[b]
}
return(interest = round(sum(value), 2))
}
```

### Find the most popular movies and the most active users

After building the function, we want to select the most popular movies to see how this function works. That is, we want to visualize the interest value. However, the dataset only contains about 3700 tags labeled by the users. The limited dataset will destroy the credibility of the tag-based recommendation system, as the user we want to analyze may have a few tags and there may also a few tags for movies. In order to making sure that the interest values to be nonzero, we will then choose several movies that have labeled most by users and select several active users. In this way, we select the users that have labeled more than 20 movies and select movies that has labeled by more than 4 users. The selected movies for example, Star Wars: Episode IV - A New Hope. The selected movies' table is shown below.


<img src="./pics/starwar.jpg" style="width:75%">   

```{r}
popular.movie = 
  remove.tag %>% 
  select(-tag, -timestamp) %>% 
  distinct() %>%
  group_by(movie_id) %>% 
  summarize(
    count = n()
  ) %>% 
  filter(count > 3) %>% 
  mutate(
    "movie id" = movie_id
  ) %>% 
  select(-movie_id) %>% 
  select("movie id", count) %>% 
  arrange(desc(count))

active.user = 
  remove.tag %>% 
  select(-tag, -timestamp) %>%
  distinct() %>% 
  group_by(user_id) %>% 
  summarize(
    count = n()
  ) %>% 
  filter(count > 20) %>% 
  arrange(desc(count))

active.user.vec = as.vector(active.user$user_id)
popular.movie.vec = as.vector(popular.movie$`movie id`)

movie.name = 
  movies %>% 
  janitor::clean_names() %>%
  filter(movie_id %in% popular.movie.vec) %>% 
  knitr::kable() %>% 
  kable_styling(bootstrap_options = c("striped")) %>%
  kableExtra::kable_styling(font_size = 12)

movie.name
```

### Create heat map

To visualize the users' interest values, we decided to create a heat map. A heat map (or heatmap) is a data visualization technique that shows magnitude of a phenomenon as color in two dimensions. The variation in color may be by hue or intensity, giving obvious visual cues about how the phenomenon is clustered or varies over space. The heat map is shown below. The horizontal coordinate of the heat map is the movie ID and the vertical coordinate is the user ID, each corresponding color represents the level of the user's interest in the movie. The brighter the color (the greater the interest value), the deeper the interest, and the darker the color (the smaller the interest value), the lighter the interest.

```{r}
# construct a new table of the selected id and movie
heat.map = tibble(user_id = rep(active.user.vec, length(popular.movie.vec)), movie_id = rep(popular.movie.vec, length(active.user.vec)))

# add insterest value to the table
interest = c()
for (i in 1:nrow(heat.map)) {
  interest[i] = fc.interest(as.numeric(heat.map[i, 1]), as.numeric(heat.map[i, 2]))
}

heat.map = add_column(heat.map, interest)

# build heat map
heat.map %>% 
  ggplot(aes(y = as.factor(user_id), x = as.factor(movie_id), fill = interest)) +
  geom_tile() +
  geom_raster() +
  labs(
    x = "Movie ID",
    y = "User ID"
  )

```

### Conclusion

Tag based TF-IDF can help us predict the user's interest on a certain movie (or item). The algorithm's validity relies on a large dataset. That is, when enlarging the dataset, the system will become more and more accurate. In this way, the system works well for big websites due to their large user groups. 

The algorithm above have punishment for popular tags and popular movies, and doesn't reduce the accuracy of the recommendation results while enhancing the personalization of the recommendation results.






